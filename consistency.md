# Merkle Tree Consistency Analysis

## Hypothesis A: Full Tree Rebuilds Always Produce Consistent Trees

### Initial Justifications

1. **Row Order Determinism**
   - The table query `SELECT id, data, leaf_hash FROM append_only_log ORDER BY id` ensures deterministic ordering
   - Trees are built by inserting leaves in this deterministic order
   - Therefore, given the same set of rows, rebuilds will always produce identical trees

2. **Monotonic Growth**
   - Trees built at different times should be consistent if the later tree includes all rows from the earlier tree
   - Initial concern: What if gaps in the PostgreSQL id sequence are later filled, causing rows to be inserted "between" existing rows?

### PostgreSQL Sequence Behavior Analysis

After investigating PostgreSQL's sequence (auto-increment) behavior, we found important guarantees:

1. **Gap Permanence**
   - Once a sequence value is consumed, it is never reused automatically
   - Gaps created by failed/rolled back transactions remain as gaps
   - The `nextval()` function always generates strictly increasing values, skipping over any gaps

   > "Sequence objects are special single-row tables created with CREATE SEQUENCE. Sequence numbers are generated by successful calls to the nextval function. [...] If a transaction that called nextval is later rolled back for any reason, the sequence number which was allocated is not reused." [^1]

2. **Gap Filling Conditions**
   Gaps in the sequence can only be filled under specific conditions:
   - Explicit INSERT with a specific ID in the gap
   - Manual sequence reset to a lower number
   - Sequence wraparound (not considered in our analysis)

   > "Once a sequence is created, you cannot change the minimum value [...] To start the sequence at a different value, you must DROP and CREATE it again, or use ALTER SEQUENCE RESTART." [^2]

[^1]: [PostgreSQL Documentation: Sequence Manipulation Functions](https://www.postgresql.org/docs/current/functions-sequence.html)
[^2]: [PostgreSQL Documentation: CREATE SEQUENCE](https://www.postgresql.org/docs/current/sql-createsequence.html)

### Transaction Visibility Analysis

An important objection to consider: During high write activity, could a `SELECT ... ORDER BY id` see an inconsistent view of the table where some lower-id transactions are incomplete while higher-id transactions are visible?

Example scenario:
```
Time | Transaction 1     | Transaction 2     | ID Sequence
-----|------------------|------------------|------------
t1   | Gets ID=5        | Gets ID=6        | next=7
t2   | Still writing... | Commits          | next=7
t3   | SELECT * ORDER BY id executed here
```

PostgreSQL's MVCC (Multi-Version Concurrency Control) rules:
1. A query sees only data committed before it began
2. Row visibility is determined by transaction commit time, not ID order
3. The sequence number allocation is separate from transaction commit

> "PostgreSQL maintains this guarantee by not releasing to other transactions the results of a sequence object's nextval operation until the transaction that performed the operation commits [...] this means that transaction rollback completely cancels the effects of all nextval operations performed during the transaction." [^3]

> "A transaction sees data in the database as it was when it started, not as it was when each individual statement within it started [...] each SQL statement sees the effects of previously committed transactions plus any changes made by earlier statements in the same transaction." [^4]

[^3]: [PostgreSQL Documentation: Sequence Manipulation Functions - Transaction Behavior](https://www.postgresql.org/docs/current/functions-sequence.html#id-1.5.8.33.5)
[^4]: [PostgreSQL Documentation: Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)

This means that at t3:
- ID=6 would be visible (committed)
- ID=5 would be invisible (uncommitted)
- `SELECT ... ORDER BY id` would see ID=6 but not ID=5

However, when Transaction 1 eventually commits, a new `SELECT` would see both rows in correct order. Critically, **there is no way for a query to see rows in an order that violates their ID sequence**.

### Revised Conclusion

Our analysis shows two key safety properties:
1. Gaps cannot be automatically filled (PostgreSQL sequence guarantee)
2. Transactions cannot create "holes" in the visible sequence (MVCC guarantee)

This means that trees built at different times will be consistent as long as:
1. We only use auto-increment for IDs (no manual ID insertion)
2. We don't reset the sequence
3. We don't hit sequence wraparound

## Hypothesis B: Incremental Tree Build Consistency

### Statement
Incremental tree builds will always produce trees consistent with a full rebuild, or halt.

### Why Buffering is Necessary

Consider what would happen without our buffering mechanism:

```
Scenario: Rows inserted with IDs [1, 2, 3] but notifications arrive out of order

Without buffering:
1. Notification for ID=2 arrives first → Tree state: [hash2]
2. Notification for ID=1 arrives second → Tree state: [hash2, hash1]
3. Notification for ID=3 arrives last → Tree state: [hash2, hash1, hash3]
Final tree state: [hash2, hash1, hash3]

Full rebuild later:
1. SELECT ... ORDER BY id returns rows in correct order
2. Tree built as: [hash1, hash2, hash3]
Final tree state: [hash1, hash2, hash3]

Result: Trees are inconsistent!
```

This inconsistency occurs because the order of leaves in a Merkle tree directly affects all hash calculations above them. Different leaf orders produce different root hashes and different proofs.

### Justification

1. **Strict Sequential Processing**
   - The notification handler enforces strict sequential processing of rows by ID
   - Uses a buffer (BTreeMap) to handle out-of-order notifications
   - Only processes a row when all prior IDs have been processed
   - Will not skip gaps in the sequence

2. **Halting Conditions**
   - If a notification is dropped/missed, the handler will halt at that ID
   - Example:
     ```
     Processed: [1, 2, 3]
     Received notification for ID 5
     Missing notification for ID 4
     → System buffers 5, waits for 4
     → Tree stops growing but remains consistent
     ```

3. **Recovery via Full Rebuild**
   - If the handler halts due to a gap, a full rebuild can recover
   - Full rebuilds tolerate gaps (as established in Hypothesis A)
   - After rebuild, handler can continue from new next_id
   - No inconsistency is introduced during this recovery

### Interesting Property
This creates an interesting asymmetry:
- Incremental builds: Cannot process past gaps → More restrictive
- Full rebuilds: Can process with gaps → More permissive
- But both maintain consistency with each other

### Important Implications
1. Service may halt but will never produce inconsistent trees
2. Recovery is always possible via full rebuild
3. System provides safety (consistency) over liveness (continuous operation)

## Checkpoint-Based Consistency Guarantee

### Key Insight
The order of tree construction is not fundamentally important for consistency - what matters is that we achieve the same order every time **for externally published states**. This leads to a powerful alternative approach to consistency guarantees.

### Checkpoint-Based Consistency Model

1. **Designated Checkpoints**
   - Define specific points where tree state becomes "official" or "published"
   - These are the only states against which external verifiers will check proofs
   - Example: Every N rows, or at specific time intervals

2. **State Persistence at Checkpoints**
   ```
   Checkpoint State:
   root_hash: [bytes]
   rows: [
     {id: 1, position: 0},
     {id: 4, position: 1},
     {id: 2, position: 2},
     ...
   ]
   ```
   - At each checkpoint, persist:
     - The root hash
     - The exact sequence of row IDs used
     - Their order in the tree construction

3. **Guaranteed Reconstruction**
   - When rebuilding up to a checkpoint:
     - Use the persisted row sequence exactly
     - Enforce the stored ordering
     - Verify resulting root matches stored root
   - Any deviation from stored sequence → Fail rebuild

### Advantages of this Approach

1. **Stronger Consistency Guarantee**
   - No reliance on PostgreSQL sequence behavior
   - No reliance on transaction isolation levels
   - No vulnerability to gap filling
   - Order of rows explicitly stored, not inferred

2. **Verifiable Reconstruction**
   - Can prove correct reconstruction by comparing root hash
   - Any deviation in row selection or ordering will produce different root

3. **Clear Boundary Between Checkpoint and Working State**
   - Up to checkpoint: Absolute consistency guaranteed
   - Beyond checkpoint: Normal operational rules apply
   - Clear distinction between "verified" and "in progress" states

4. **Flexibility in Implementation**
   - Could store checkpoints in separate table
   - Could implement as periodic snapshots
   - Could tie checkpoints to business events

### Implementation Considerations

1. **Storage Requirements**
   - Need to store row IDs and order for each checkpoint
   - Storage grows with tree size
   - Could prune old checkpoints if not needed

2. **Performance Impact**
   - Additional writes at checkpoint time
   - Additional validation during rebuild
   - Trade-off: stronger guarantees vs overhead

3. **Recovery Process**
   - Rebuild to last checkpoint using stored sequence
   - Then continue with normal operation
   - Clear process for handling deviation

## Open Questions and Future Analysis

1. What happens if we do allow manual ID insertion?
2. How do we handle sequence wraparound in production?
3. Should we add safeguards against manual ID insertion or sequence resets?
4. Should we implement automatic detection of halted state and trigger rebuild?
5. Could we make incremental builds gap-tolerant without sacrificing consistency?
6. How frequently should checkpoints be created?
7. How to handle very large checkpoint state storage?
8. Should checkpoints be tied to external events (like blockchain blocks)?

*[Document will be updated as analysis continues]*